"""
*3の第1桁を置き換えることで, 13, 23, 43, 53, 73, 83という6つの素数が得られる.

56**3の第3桁と第4桁を同じ数で置き換えることを考えよう. この5桁の数は7つの素数をもつ最初の例である:
56003, 56113, 56333, 56443, 56663, 56773, 56993. よって, この族の最初の数である56003は, このような性質を持つ最小の素数である.

桁を同じ数で置き換えることで8つの素数が得られる最小の素数を求めよ. (注:連続した桁でなくても良い)
"""
import csv
import itertools
from functools import reduce

# 10万個の素数を読み込みprimelistに保管する。
primelist = []
with open('prime.csv') as csvfile:
    primelist = [row for row in csv.reader(csvfile)]



# 与えれた文字列(s)にある文字(i)の位置情報をidlistで返す。
def indexsearch(s, i):
    c = s.count(i)
    idlist = []
    sp = 0
    while c > 0:
        ind = s.index(i, sp)
        idlist.append(ind)
        sp = ind + 1
        c -= 1
    return idlist


# 与えられた数字n の各桁（c で与えられる位置）をmで置き換えて数字で返す。少々変更
# 1~9に置き換えた数字のリストを返す。
def changedigt(n, c):
    candiateList = []
    l = [int(x) for x in list(str(n))]
    for m in range(10):
        for i in c:
            l[i] = m
        candiateList.append(int(reduce(lambda x, y:x + y, [str(x) for x in l])))
    return candiateList


# 入れ替えられた数字群が素数であるかの判断、10個の内8個以上あるかどうかを判断
def judge8(judge):
    count = 0
    for q in judge:
        if q > 1000 and str(q)[0] != '0' and [str(q)] in primelist:
            # if q in result3:
            count += 1
    if count > 7:
        print(judge)
        return True
    else:
        return False


# 10万個の素数の中で同じ数字を3個以上含む素数を抽出 ---> result(与えられた素数、同じ数字、[位置情報]）
result = []
for i in range(10):
    si = str(i)
    for l in primelist:
        if l[0].count(si) > 2:
            result.append([int(l[0]), i, indexsearch(l[0], si)])


# メイン result から、候補を選び、それの数字をいれかえたものが8つ以上の素数を生み出すものをリスト化する
result1 = []
for candiate in result:
    c_list = list(itertools.combinations(candiate[2], 3))  # 入れ替える位置を組み合わせで決定する。
    for cl in c_list:
        # print(cl)
        # print(candiate)
        if judge8(changedigt(candiate[0], cl)):
            result1.append(candiate[0])

print(result1)

""" 
answer
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[20303, 121313, 222323, 323333, 424343, 525353, 626363, 727373, 828383, 929393]
[40609, 141619, 242629, 343639, 444649, 545659, 646669, 747679, 848689, 949699]

[121313, 141619, 222323, 242629, 323333, 343639, 424343, 444649, 525353, 626363, 646669, 747679, 828383, 929393, 949699]

"""

# 位置情報から、3つの組み合わせを求める
# p_list = list(itertools.combinations(result[0][2], 3))
# print(p_list)
# print(list(result[0][0])[p_list[0][0]] )

# for pattern in ['1{3}', '2{3}', '3{3}', '4{3}', '5{3}', '6{3}', '7{3}', '8{3}', '9{3}', '0{3}']:

#         if re.findall(pattern, l[0]) != []:
#             result.append(l[0])
